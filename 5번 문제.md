## 1. 개요

HashMap 은 키를 통해 요소(element)를 검색할 수 있다.

키와 값으로 이루어진 목록이 있다고 가정할 때 원하는 키를 찾으려면 어떻게 해야될까?
- 원하는 키를 찾을 때 까지 모든 목록을 순회한다.
- 원하는 키를 특정 계산을 통해 바로 찾는다.

1번 방법의 시간 복잡도는 O(N) 이다. 만약 List 가 정렬이 되어있는 경우, Binary search tree 인 경우 O(logN) 의 시간 복잡도를 가진다.

2번 방법의 경우 시간 복잡도는 평균 **O(1)**이다. 그리고 HashMap 은 2번 방법으로 구현되어있다. 그렇다면 HashMap이 어떻게 동작하는 지 상세하게 알아보자.


### 1.2 key 의 적당한 갯수는?

>그렇다면 요소가 몇 개가 들어갈 지도 모르는 상황에서 키는 몇 개를 생성해야 할까?

예를 들어 키가 단순히 알파벳 소문자라고 가정해보자. 이 경우에 26 개의 키 목록만 있으면 충분하고 'd' 키가 있는 엘리먼트에 접근하려는 경우 위치가 4 이므로 직접 찾을 수 있다.

하지만 사용자가 다음과 같이 선언했을 때를 생각해보자.

```java
HashMap<Integer, String> map = new HashMap<>();
```

Integer.MAX_VALUE 의 값은 2,147,483,647 이다. 아무리 데이터가 많다 해도 정수의 최댓값까지 모든 요소가 가득 차 있을 수는 없다. 이 경우 할당된 메모리의 많은 부분이 사용되지 않은 상태가 되므로 공간이 낭비되고 검색 효율도 나빠진다.

그래서 HashMap은 **버킷(bucket)**에 요소를 저장하고 이러한 버킷의 수를 **용량(capacity)** 라고 한다. bucket 을 우리말로 번역하면 양동이가 되는데 요소를 담는 양동이라고 생각하면 편하다

Map 컬렉션에 값을 넣을 때 키의 hashCode() 메서드는 값이 저장될 버킷을 결정하는 데 사용된다. 그리고 값을 검색하기 위해 HashMap 은 hashCode()를 사용하여 동일 방식으로 버킷을 계산한다. 그런 다음 해당 버킷에서 찾은 객체를 순회해서 키의 equals() 메서드를 이용해 정확히 일치하는 항목을 찾는다.

정리하면, HashMap 은 모든 요소를 순회하는 것이 아니라 키를 기반으로 값의 위치를 계산한다.



### 1.3 해시 충돌

>요소를 넣을 때도 필요한 만큼만, 찾을 때도 키를 바로 찾기 때문에 어떤 조건에서도 시간 복잡도가 O(1) 일 것 같지만, 최악의 상황에 시간 복잡도가 O(N) 이 될 수도 있다.

기본적으로 동일한 키에 동일한 해시가 있어야 되지만 다른 키에 동일한 해시가 있을 수 있다.
다른 키이면서 동일한 해시인 경우 해당 키에 속한 값은 **동일한 bucket에 저장**된다.

버킷 내부에서 값은 List에 저장되고 모든 요소를 순회하여 검색한다. 이 때의 시간 복잡도는 O(N)이 된다. Java 8 부터 버킷 한 개에 8개 이상의 값이 포함되는 경우 List 에서 balanced tree 로 변경되는데 시간 복잡도는 O(logN) 이다.

해시 충돌에 대한 Java 의 자세한 내용은 아래의 사이트에서 참고하면 된다.
**(https://d2.naver.com/helloworld/831311)**

## 2. HashMap 의 내부 구현

이제 원리를 알았으니 Java 코드를 통해 생성자와 주요 메서드가 어떻게 구현되어 있는지 확인해보자.


### 2.1 생성자

다음은 Java 의 HashMap 클래스의 내부 코드이다.

```java
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

   
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

   
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }

    
    public HashMap(Map<? extends K, ? extends V> m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
```

생성자의 매개변수로 initialCapcity 와 loadFactor 가 있다.

#### 2.1.1 initialCapacity

버킷의 초기 용량을 설정하는 파라미터이다. 기본 초기 용량은 16이다.
참고로 HashMap은 값이 여러 개인 bucket 을 막기 위해 bucket 의 75% 가 비어 있지 않으면 capcity 는 자동으로 두 배가 된다.

#### 2.1.2 load factor

HashMap 의 버킷 용량을 증가시키는 백분율 값이다.
기본값은 0.75f 이며, 용량의 75%가 채워지면 Rehashing 이 발생한다는 것을 뜻한다.

>Rehashing?
>>만약 버킷의 용량이 임계값에 도달하면 Java 는 용량을 두 배씩 증가시키는데 이것을 Rehashing 이라고 한다.
ex) 2<sup>4</sup>, 2<sup>5</sup>, 2<sup>6</sup> ...


### 2.2 메서드

HashMap 에는 많은 메서드가 있지만 검색과 삽입에 주로 사용하는 put()과 get() 메서드를 집중적으로 설명하겠다. 나머지 메서드는 자바 공식 API 문서를 참고하면 된다.
링크: https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html

#### 2.2.1 put() 메서드

다음은 put 메서드를 구현한 Java 코드이다.

```java
V put(K key, V value);
```

그리고 아래 코드는 예제 코드이다. 원래라면 키와 값이 추가됐을 때, 키 객체의 hashCode() 가 호출되어 초기 해시 값을 검색하지만, 아래 예제 코드에서 재정의된 hashCode()는 메서드가 호출되었다는 출력만 나타나게끔 작성했다.

```java
public class CustomKey{
    private int id;

   	//Getter, Setter, Constructor

    @Override
    public int hashCode() {
        System.out.println("hashCode Method called");
        return id;
    }
}
```

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        CustomKey key = new CustomKey(1);
        Map<CustomKey, String> map = new HashMap<>();

        map.put(key, "value");
    }
}
```

main 함수를 실행하면 hashCode() 메서드가 실행되었다는 hashCode Method called 가 출력된다. 

다음으로 볼 메서드는 hash() 메서드이다. 이 메서드는 초기 해시 값을 통해 최종 해시 값을 계산한다. 이 최종 해시 값이 내부 배열의 인덱스 또는 버킷 위치가 된다. 메서드의 구현 부분은 다음과 같다.

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

return 되는 값을 보면 최종 해시 값을 계산하기 위해 key 객체의 hashCode 만 사용하는 것을 볼 수 있다. 그리고 put 함수 내부에서 최종 해시 값은 다음과 같이 사용된다.

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

내부 putVal 메서드의 첫번째 매개변수인 hash(key) 가 최종 해시 값이다.
이미 hash 값을 계산하는 데 key를 사용했는데 메서드 두번째 매개변수로 다시 key 를 사용하는 이유는 해시 맵이 **버킷 위치에 키와 값을 모두 Map.Entry 객체로 저장**하기 때문이다.

Java 의 Collection 프레임워크에 Map이 구현되어 있지 않은 이유도 이것 때문이다.
Map 이 다른 컬렉션처럼 단일 요소를 정확히 저장하는 것이 아니라 키-값 쌍의 컬렉션을 저장하기 때문에, add 같은 Collection interface 의 메서드는 Map 에서 의미가 없다.

#### 2.2.2 get() method

이미 저장된 객체를 찾기 위해 해당 객체가 저장된 키를 알아야 한다. get() 도 put()과 마찬가지로 동일한 해싱 작업을 실행한다.

초기 해시 값을 얻기 위해 객체의 hashCode() 메서드가 호출된다. 그리고 hash() 메서드를 호출해서 최종 해시 값을 얻고 이 값을 통해 버킷 위치를 찾는다.

#### 2.2.3 null 허용

HashTable 과 달리 HashMap은 키와 값에 null을 허용한다. put() 메서드가 실행되는 도중에 null 키를 발견하면 자동으로 최종 해시 값은 0이 되고 이것은 HashMap의 가장 첫 번째 요소가 된다는 것을 의미한다. 키가 null 일 때 이미 값은 0이므로 hash() 작업이 발생하지 않아 NullPointerException 은 발생하지 않는다.










