# Java 언어의 설계적 결함



## 1. Stack



자바 `Stack` 은 `Vector` 을 상속받고 있습니다.

`Stack` 자료 구조는 LIFO 구조이므로 중간에 값 삽입이 절대 가능해서는 안 됩니다.

하지만 `Vector` 클래스의 다음과 같은 코드 때문에 Stack 은 값 중간에 삽입이 가능합니다.

```java
    /**
     * Inserts the specified element at the specified position in this Vector.
     * Shifts the element currently at that position (if any) and any
     * subsequent elements to the right (adds one to their indices).
     *
     * @param index index at which the specified element is to be inserted
     * @param element element to be inserted
     * @throws ArrayIndexOutOfBoundsException if the index is out of range
     *         ({@code index < 0 || index > size()})
     * @since 1.2
     */
    public void add(int index, E element) {
        insertElementAt(element, index);
    }
```

실제 코드에서도 인덱스 사이에 값이 들어갈 수 있음을 확인할 수 있습니다.

```java
public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.add(1, 22);

        System.out.println("stack.pop() = " + stack.pop());
        System.out.println("stack.pop() = " + stack.pop());
        System.out.println("stack.pop() = " + stack.pop());
    }
}
```



다만 이 부분은 큰 문제가 아니라고 생각됩니다. 아직까지 `Stack` 리스트를 지원하는 것은 자바의 하위 호환성을 위한 것이기도 하고 자바 1.0이 나온지 한참이 지났기 때문에 공식 문서를 한 번이라도 읽어봤다면 더 이상 사용자가 쓰지 않으면 되는 문제이기 때문입니다.

정말 레거시여서 `Stack` 을 사용하고 있다고 해도 자바에서 제공하는 `Deque` 로 대체하기만 하면 됩니다.



Deque 는 자료구조인 큐와 스택을 전부 사용할 수 있는 자바의 자료 구조입니다.

```java
Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are equivalent to Deque methods as indicated in the table below:
Comparison of Stack and Deque methods
  
Stack Method
Equivalent Deque Method
push(e) ==> addFirst(e)
pop() ==> removeFirst()
peek() ==> getFirst()
```



스택 자료구조로써 Deque 를 사용하려고 할 때 레퍼런스의 설명대로 함수만 치환해주면 됩니다.



```java
public static void main(String[] args) {
        Deque<Integer> deque = new ArrayDeque<>();

        deque.addFirst(1);
        deque.addFirst(2);
        deque.addFirst(3);

        System.out.println("deque.removeFirst() = " + deque.removeFirst());
        System.out.println("deque.removeFirst() = " + deque.removeFirst());
        System.out.println("deque.removeFirst() = " + deque.removeFirst());
    }
```



## 2. variance

한국어로 번역하면 공변성이 됩니다. 하지만 한국말이 더 어려우므로 그냥 레퍼런스에 나오는 용어대로 설명하겠습니다.

자바는 완벽하게 contravariance 와 covariance 를 지원하지 않습니다. 타입 안정성을 위해 지원하지 않기로 결정한것이지만, 이것때문에 설계적 결함이 생겨나게 되었습니다.

다음 예제는 런타임 에러가 발생합니다.

```
    public static void main(String[] args) {
        Object[] objectArray = new String[10];
        objectArray[0] = Integer.valueOf(1);
    }
```

Covariance 는 상위 클래스(Object)가 예상되는 하위 클래스(String)를 사용할 수 있는 경우를 뜻합니다. 이 예제로 설명하면 String 이 Object 의 하위 클래스인 경우이므로 String 타입을 Object 타입의 배열에 할당할 수 있음을 의미합니다. 하지만 이것으로 인해 런타임 예외인 `ArrayStoreException` 이 발생합니다.

자바의 제네릭은 invariant 입니다. 즉 `String`이 `Object`하위 유형이라고 해도  `List<String>`  은 `List<Object>` 의 하위 유형이 아닙니다. 직관적이지 않죠? 그래서 자바는 이런 문제들을 해결하기 위해 와일드카드를 제공합니다.

아래 코드는 런타임 에러가 아닌 컴파일 에러가 발생합니다.

```java
public class Main {
    public static void main(String[] args) {
        List<Dog> dogList = new ArrayList<>();
        List<? extends Animal> animals = dogList;

        animals.add(new Dog()); // compile error
    }
    static class Animal{}

    static class Dog extends Animal {}
}
```

컴파일 에러가 발생하는 이유는 자바에서는 `List<? extends Animal>` 과 `List<Animal>` 이 서로 다르기 때문에 발생합니다.

와일드 카드를 사용해서 컴파일 에러를 확인하고 코드를 수정한 것이 다음 예제입니다.

```java
public class Main {
    public static void main(String[] args) {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());

        List<? extends Animal> animals = dogs;
        for (Animal animal : animals) {
            System.out.println(animal.getName());
        }
    }

    static class Animal{
        String name = "Animal";

        public String getName() {
            return name;
        }
    }

    static class Dog extends Animal {
        String name = "Dog";

        @Override
        public String getName() {
            return name;
        }
    }
}
```
