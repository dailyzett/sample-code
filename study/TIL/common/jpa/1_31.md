# 목차

- [목차](#목차)
- [엔티티 설계 시 주의점](#엔티티-설계-시-주의점)
    - [1. 외래 키가 있는 곳을 항상 연관관계의 주인으로 정해라.](#1-외래-키가-있는-곳을-항상-연관관계의-주인으로-정해라)
    - [2.엔티티는 Getter는 열어둬도 Setter은 꼭 필요한 경우에만 사용한다.](#2엔티티는-getter는-열어둬도-setter은-꼭-필요한-경우에만-사용한다)
    - [3. @Embedded 값 타입은 변경 불가능하게 설계해야 한다.](#3-embedded-값-타입은-변경-불가능하게-설계해야-한다)
    - [4. 모든 연관관계는 지연로딩으로 설정한다.](#4-모든-연관관계는-지연로딩으로-설정한다)
    - [5. 컬렉션은 필드에서 바로 초기화한다.](#5-컬렉션은-필드에서-바로-초기화한다)
    - [6. 테이블, 컬럼명 생성 전략](#6-테이블-컬럼명-생성-전략)
    - [7. cascadeType.ALL](#7-cascadetypeall)
    - [8. 연관관계 편의 메서드](#8-연관관계-편의-메서드)

# 엔티티 설계 시 주의점

### 1. 외래 키가 있는 곳을 항상 연관관계의 주인으로 정해라.

연관관계의 주인은 단순히 외래키를 누가 관리하느냐의 문제지 비즈니스 상의 우위에 있다고 주인으로 정하면 안된다.


### 2.엔티티는 Getter는 열어둬도 Setter은 꼭 필요한 경우에만 사용한다.

Setter 메서드가 중구난방으로 있으면 추후 코드가 복잡해질 때 값이 어디서 바뀌는 지 추적이 매우 어렵다.

### 3. @Embedded 값 타입은 변경 불가능하게 설계해야 한다.

JPA 스펙상 임베디드 타입은 자바 기본 생성자를 _protected_ 또는 _public_ 으로 설정해야 한다.
JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플렉션을 사용할 수 있기 때문인데,
리플렉션은 기본 생성자가 없으면 작동하지 않는다.

### 4. 모든 연관관계는 지연로딩으로 설정한다.

_@XToOne_ 관계는 기본적으로 _fetchType_ 이 _EAGER_ 이다. _EAGER_ 는 JPQL 사용 시 연관된 모든 레코드를 불러오기 때문에
N+1 문제가 발생하기 굉장히 쉽다. 따라서 모든 _fetchType_ 는 _LAZY_ 로 설정하고, 정말 필요한 부분만 _EAGER_ 을
사용하는 것이 좋다.

### 5. 컬렉션은 필드에서 바로 초기화한다.

- null 문제에서 안전해진다.
- 하이버네이트는 엔티티를 영속화할 때 컬렉션을 감싸서 하이버네이트 전용 내장 컬렉션으로 변경한다.
이 때 컬렉션을 임의로 잘못 생성했다면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다.


```java
Member member = new Member();
System.out.println(member.getOrders().getClass());
em.persist(team);
System.out.println(member.getOrders().getClass());

//출력 결과
class java.util.ArrayList
class org.hibernate.collection.internal.PersistentBag
```

### 6. 테이블, 컬럼명 생성 전략

스프링 부트 신규 설정(엔티티 -> 테이블)

1. 카멜케이스 -> 언더스코어(orderDate -> order_date)
2. .(점) -> 언더스코어
3. 대문자 -> 소문자

### 7. cascadeType.ALL

원래 _persist_ 는 엔티티마다 각각 해줘야 한다.
하지만 _cascadeType.ALL_ 을 사용하면 연관된 엔티티를 자동으로 persist 해준다.

하지만 애매한 테이블 관계에서도 ALL 을 남용하면 남아 있어야 할 정보도 없애버리기 때문에 주의해야 한다.
예를 들어 회원 관리를 위해 _리뷰 작성 히스토리 테이블_ 이 있다고 가정할 때, 리뷰와 히스토리 테이블이 _cascadeType.ALL_
이라면 리뷰를 삭제하면 히스토리 테이블도 같이 삭제된다.

### 8. 연관관계 편의 메서드

객체 그래프 탐색을 위해 연관관계가 있는 엔티티들은 양방향으로 값이 존재해야 한다.
연관관계 메서드가 있는 곳은 연관관계에 있는 엔티티를 주로 컨트롤 하는 클래스에 생성하는 것이 좋다.

> **예시:**
```java
//연관관계 메서드
public void setMember(Member member) {
    this.member = member;
    member.getOrders().add(this);
}
```
