# 목차

- [목차](#목차)
- [6.7 애노테이션 트랜잭션 속성과 포인트컷](#67-애노테이션-트랜잭션-속성과-포인트컷)
  - [6.7.1 트랜잭션 애노테이션](#671-트랜잭션-애노테이션)
    - [트랜잭션 속성을 이용하는 포인트컷](#트랜잭션-속성을-이용하는-포인트컷)
    - [대체 정책](#대체-정책)
      - [트랜잭션 애노테이션 사용을 위한 설정](#트랜잭션-애노테이션-사용을-위한-설정)

# 6.7 애노테이션 트랜잭션 속성과 포인트컷

클래스나 메서드에 따라 제각각 속성이 다른, 세밀하게 튜닝된 트랜잭션 속성을 적용해야하는 경우가 있다.
이런 경우라면 메서드 이름 패턴을 이용해서 일괄적으로 트랜잭션 속성을 적용하는 방식은 옳지 않다.
기본 속성과 다른 경우가 있을 때마다 일일이 포인트컷과 어드바이스를 새로 추가해줘야 하기 때문이다.

이런 세밀한 트랜잭션의 속성의 제어가 필요하다면 직접 타깃에 트랜잭션 속성정보를 가진 **애노테이션을 지정하는 방법**을 사용해야 한다.

## 6.7.1 트랜잭션 애노테이션

- **@Transactional**

@Transactional 애노테이션의 타깃은 메서드와 타입이다.
따라서 메서드, 클래스, 인터페이스에 사용할 수 있다.
@Transactional 애노테이션을 속성정보로 사용하면 스프링은 이 애노테이션이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다.
@Transactional 애노테이션은 기본적으로 트랜잭션 속성을 정의하는 것이지만, 동시에 포인트컷의 자동등록에도 사용된다.

### 트랜잭션 속성을 이용하는 포인트컷

![img_14.png](image1/img_14.png)

@Transactional 애노테이션을 사용했을 때 어드바이저의 동작방식을 보여준다.
이 방식을 사용하면 포인트컷과 트랜잭션 속성을 애노테이션 하나로 지정할 수 있다.

트랜잭션 부가기능 적용 단위는 메서드다.
메서드마다 @Transactional 애노테이션을 부여하고 속성을 지정할 수 있다.
이렇게 하면 유연한 속성 제어는 가능하겠지만 코드는 지저분해지고, 동일한 속성 정보를 가진
애노테이션을 반복적으로 메서드마다 부여해주는 바람직하지 못한 결과를 가져올 수 있다.

### 대체 정책

그래서 스프링은 @Transactional 을 적용할 때 4단계의 대체(fallback)정책을 이용하게 해준다.
메서드의 속성을 확인할 때 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입의 순서에 따라서 @Transactional이 적용됐는지
차례대로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.

> **주의 사항.**<br/>
> @Transactional 적용 대상은 클라이언트가 사용하는 인터페이스가 정의한 메서드이므로 타깃 클래스보다는 인터페이스에 두는게 바람직하다.
> 하지만 인터페이스를 사용하는 프록시 방식의 AOP가 아닌 방식으로 트랜잭션을 적용하면 인터페이스에 정의한 @Transactional은 무시되기 때문에
> 안전하게 타깃 클래스에 @Transactional을 두는 방법을 권장한다.

#### 트랜잭션 애노테이션 사용을 위한 설정

```xml
<tx:annotation-driven />
```


