## ArrayList vs HashMap


#### 특징

- HashMap은 처음 인덱스를 찾을 때 느리고, 공간 활용은 ArrayList 에 비해 떨어진다.
- 다만 찾으려는 인덱스 값이 커질 수록 속도가 빨라진다.


#### 이유

- ArrayList
  - ArrayList 는 배열이 인덱스를 기반으로 하기 때문에, 모든 element에 접근하는데 항상 일정한 시간 O(1)이 걸린다.
  - 특정 위치/인덱스에 element를 추가할 때를 제외하고 새 element 를 추가하는 데도 O(1)이 걸린다
  - 특정 element 에 접근하는 것은 O(n) 시간이 걸린다.
  - element를 제거할 때는 제거를 위해 선택한 element 를 찾기 위해 전체 배열을 반복해야 한다.
- 함수별 빅오
```java
add() // O(1)이지만 신규 배열을 생성하고 모든 element를 배열에 복사해야하는 경우 O(N)
add(index, element) // O(N)
get() // 항상 O(1)
remove() // O(N)
indexOf() // O(N)
contains // O(N)
```

> ArrayList 는 인덱스를 기반으로 항목에 접근하는 것은 매우 빠르지만, 값(value)을 기준으로 항목을 검색하거나 특정 위치에 삽입/제거하는 것은 시간이 오래 걸린다.
> 따라서 ArrayList는 동일한 순서를 유지하는 것이 중요하고, 인덱스 기반으로 빠른 접근을 하려고 할 때 사용하는 것이 좋다.

- HashMap
  - 키와 값을 한 쌍으로 저장해야하기 때문에 공간 효율성은 떨어지지만 키를 기반으로 값을 검색하는데 매우 효율적이다.
  - 검색에 평균적으로 O(1)이 걸린다
  - **키를 모른 채** element 를 확인하는 것은 모든 element 를 반복해야하기 때문에 O(N) 이다.
  - HashMap은 인덱싱을 사용하여 특정 값으로 점프를 하기 때문에, 대규모 컬렉션의 경우에도 검색 시간이 일정하다.

- 특징
  - HashMap 은 버킷에 element 를 저장하고 버킷의 수를 용량(capacity)라고 한다.
  - HashMap 이 서랍이라면 bucket 은 서랍장, 각 element 들은 서랍장 내에 분류해놓은 내용물이라고 보면 된다.
  - bucket 의 수를 적게 유지하면 각 버킷에 들어가는 element 들이 많아지므로 검색이 느려진다.
  - 반대 상황일 때 공간은 많이 잡아먹으나 그에 해당하는 element 들을 빠르게 찾을 수 있다.
  - load factor 란 **총 수용가능한 element 의 수 / 용량** 으로 정의된다.
    - load factor 가 크다는 것은 버킷에 element 를 많이 넣는다는 뜻이다. 따라서 검색 효율이 떨어진다
    - load factor 가 작다는 것은 버킷에 element 를 적게 넣는다는 뜻이다. 따라서 검색 효율이 높아지지만 공간을 많이 잡아먹는다
  
- 함수별 빅오
```java
//매개변수는 생략
put() // O(1)
get() // O(1)
```


> HashMap 을 사용 하는 것은 저장하려는 데이터에 고유 키를 사용할 수 있는 경우에만 쓸모가 있다. 만약 컬렉션에서
> 항목의 동일한 순서를 유지해야한다면 HashMap은 사용하지 않는 것이 옳다.


