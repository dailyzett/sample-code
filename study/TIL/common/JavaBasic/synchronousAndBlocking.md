### 1. 동기와 비동기

처리해야 할 **작업들을** 어떠한 흐름으로 처리할 것인가에 대한 관점이다.

#### 동기

호출하는 함수가 호출되는 함수의 리턴을 기다리거나, 미완료 상태인 경우 작업 완료 여부를 지속적으로 체크한다면 이것은 동기 방식이다.

#### 비동기 

호출하는 함수가 다른 함수를 호출할 때 콜백 함수를 함께 전달해서, 다른 함수의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.
즉 호출하는 함수는 다른 함수의 작업 완료 상태를 신경쓰지 않는다.

### 2. 블로킹과 논블로킹

처리되어야 하는 **하나의 작업**이 전체적인 작업의 흐름을 막느냐 안막느냐에 대한 관점이다.
즉 작업에 대한 제어권이 누구한테 있느냐가 관심사이다.

#### 블로킹

애플리케이션이 블로킹 시스템 호출을 수행하면, 애플리케이션의 실행은 일시 중단된다.
이 때 애플리케이션이 OS의 실행 큐(run queue)에서 대기 큐(wait queue)로 이동한다.
시스템 호출이 완료되면 애플리케이션은 다시 실행 큐로 돌아간다.

#### 논블로킹

논블로킹은 애플리케이션의 실행을 중단하지 않는다.
즉, 논블로킹은 OS 대기 큐에 들어가지 않는다.
그리고 논블로킹은 시스템 호출이 완료되지 않아도 빠르게 값을 리턴한다.


### 3. 동기/비동기 vs 블로킹/논블로킹

두 개념들을 정리하면 다음과 같다.
- 동기/비동기는 **프로세스의 수행 순서에 대한 보장**을 의미한다.
- 블로킹/논블로킹은 **프로세스의 유휴 상태에 대한 개념**이다.

이 개념들은 서로와 직접적인 관계가 없기 때문에 섞어서 사용 가능하다.

- 동기이면서 블로킹
- 동기이면서 논블로킹
- 비동기이면서 블로킹
- 비동기이면서 논블로킹

이 종류들을 사장과 직원 입장에 대입해보면 다음과 같다.

#### 동기 - 블로킹
```text
사장 : 일을 준다.
직원 : 일을 한다.
사장 : (일을 할 때 까지 아무것도 안함)
직원 : 일이 끝나고 사장에게 보고
```

> ex) Java 에서 콘솔에서 입력을 받을 때, 그 입력을 받을 때까지 콘솔창은 아무런 행동도 취하지 않는다.
이것은 제어권이 콘솔에서 사용자에게 넘어가고, 리턴값이 반드시 필요한 동기 방식이기 때문이다.

#### 동기 - 논블로킹


```text
사장 : 일을 준다. 
직원 : 일을 한다.
(잠시후)
사장 : 일 다하셨나요?
직원 : 아직요.
(잠시후)
사장 : 일 다하셨나요?
직원 : 아직요
(잠시후)
사장 : 일 다하셨죠?
직원 : 네 다했습니다. 여기요
```

사장 입장에서는 직원의 일이 다 했을 때, 리턴받아야 되기 때문에 함수 흐름은 **순차적(동기)** 으로 실행된다.
다만 일을 확인하는 제어권은 사장한테 계속 있기 때문에 중간중간 직원에게 해당 일을 완료했는 지 물어본다.

> ex) 게임에서 데이터 로드율을 표시할 때 사용할 수 있다.
> 로딩이 끝나지 않았는데 게임을 비동기 방식으로 실행해버리면 오류가 날 것이다.
> 따라서 시스템이 계속해서 데이터 로드가 완료될 때까지 상태를 묻고, 완료되면 그 데이터를 리턴한다.

#### 비동기 - 논블로킹

```text
사장 : 일을 준다.
직원 : 일을 한다.
이 때, 사장도 자신의 일을 한다.
그리고 직원이 일을 마쳤을 때 그 일에 대한 보고를 받는다.
```

동기 & 논블로킹과의 차이점은 직원이 일을 하고 있든 안하고 있든 사장도 자신의 일을 한다는 점이다.

그리고 논블로킹이기 때문에 제어권을 넘기지 않고, 비동기 방식으로 해당 함수가 완료되었는지 기다리지도 않는다.
비동기 방식이기 때문에 직원이 일한 보고는 미래에 **콜백** 방식으로 받는다.

> ex) AJAX 요청은
> 프론트엔드단에서 서버로 API 요청을 보내고, 응답을 기다리지 않고 바로 자신의 다음 일을 계속 실행한다.

#### 비동기 - 블로킹

사실 이 조합은 논리적으로 이상한 조합이다.
애초에 비동기 방식은 다른 함수의 리턴 값을 받지 않아도 미래에 콜백으로 받으면서, 자신의 다음 행동을
수행하기 위함이다. 하지만 블로킹 방식과 결합하면 다른 함수의 리턴 유무에 관심이 없어도 그 함수에게
제어권을 넘기기 때문에 이 함수의 작업이 끝날 때까지 기다려야하는 사태가 발생한다.

즉 관심없는 함수의 작업이 끝날 때까지 기다려야한다는 것이다.
이 경우, 동기 & 블로킹과 성능 차이가 거의 없기 때문에 사용하는 경우가 거의 없다.



