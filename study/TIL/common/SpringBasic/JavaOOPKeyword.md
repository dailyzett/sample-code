## 객체 지향을 사용하기 위한 자바의 여러 키워드

### 1. abstract 키워드

추상 메서드와 추상 클래스를 사용하기 위해 선언하는 키워드이다.
추상 메서드는 메서드의 구현체가 존재하지 않기 때문에 재정의하지 않고 사용한다면 컴파일 에러가 발생한다. 
컴파일 에러를 통해, 개발자는 이 메서드는 반드시 재정의해서 사용해야된다는 점을 쉽게 알릴 수 있다.

추상 클래스의 특징은 다음과 같다.
- 인스턴스 생성이 불가능하다.
- 추상 메서드는 하위 클래스에게 메서드 구현을 강제한다.
- 추상 메서드를 포함하는 클래스는 **반드시 추상클래스**여야 한다.

### 2. 생성자(Constructor)

```java
Person thePerson = new Person();
```

다음 코드에서 new Person() 도 일종의 메서드이다.
반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드라고 해서
**객체 생성자 메서드**라고 부른다.

클래스를 생성할 때, 아무런 설정을 하지 않아도 매개변수를 갖지않는 기본 생성자가 존재한다.
매개변수를 가지는 생성자 또한 사용자가 임의로 설정할 수 있지만 이렇게 되면 기본 생성자는 사라지기
때문에 필요하다면 따로 기본 생성자 메서드를 추가해줘야한다.

### 3. static 블록

Java에서 객체 생성자는 있지만 클래스 생성자는 존재하지 않는다. 하지만 클래스가
스태틱 영역에 배치될 때 실행되는 코드 블록이 있는데, 바로 static 블록이다.

```java
public class Person{
    static{
        System.out.println("사람 클래스입니다.");
    }
}
```
```java
public class Main{
    public static void main(String[] args) {
        Person thePerson = new Person();
    }
}
```

코드를 실행하면 출력 결과는 다음과 같다.

> 사람 클래스입니다.

클래스의 static 블록은 해당 패키지 또는 클래스가 **처음으로 사용**될 때 로딩된다.
다음 코드를 보자.

```java
public class Person {
    static {
        System.out.println("Person's static block");
    }

    public static void main(String[] args) {
        Person thePerson = new Person();
        Person theSecondPerson = new Person();
    }
}
```

> Person's static block

위 출력 결과와 같이 스태틱 블록은 단 한번만 실행된다.
클래스 정보는 **해당 클래스가 코드에서 맨 처음 사용**될 때 T 메모리의 스태틱 영역에 로딩되며,
이 때 스태틱 블록이 실행된다. 여기서 **해당 클래스가 코드에서 맨 처음 사용**될 때는 세 가지 경우 중
하나이다.

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 사용할 때

클래스들의 정보들을 T 메모리의 스태틱 영역에 바로 올리지 않는 이유는 메모리는 최대한 늦게 사용을 시작하고
최대한 빨리 반환해야 절약되기 때문이다.

### 4. final 키워드

final 키워드는 클래스, 변수, 메서드 앞에 붙을 수 있다. 각각의 특징은 다음과 같다.

- final class : 이 클래스는 상속을 허락하지 않겠다는 의미이다.
- final variable : 변경 불가능한 상수가 된다.
- final method : 메서드 재정의를 불가능하게 만든다.

### 5. instanceof 연산자

이 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 확인하는 용도로 쓰인다.
리턴값이 boolean 이기 때문에 true 혹은 false 값을 반환한다. 이 연산자는 타입 체크 용도로
강력하기는 하지만 객체 지향 설계 5원칙 가운데 LSP(리스코프 치환 원칙)을 어기는 코드에서 주로
나타나는 코드이기 때문에 리팩터링 대상이 아닌지 확인이 필요하다.

### 6. package 키워드

이 키워드는 네임스페이스를 만들어주는 역할을 한다. 협업할 때, 같은 이름의 클래스를 사용하는 일이
일어날 수 있는데, package 키워드를 이용해서 이름 공간을 나누어 충돌을 피할 수 있게 만들어준다.

### 7. 객체 메서드 호출 원리

```java
public class Person {
    void test(){
        System.out.println("TEST");
    }

    public static void main(String[] args) {
        Person Hong = new Person();
        Hong.test();
    }
}
```

위의 코드에서 TEST를 출력하는 라인에 Breakpoints를 걸면 객체명.객체메서드명()이 아니라
**클래스명.객체메서드명()** 임을 확인할 수 있다.

![img1](https://media.vlpt.us/images/dailyzett/post/0a560a88-eabb-45f7-b159-d2d701d587d4/image.png)

> test:5 에서 Person이 아닌 Hong이 나와야할 것 같은데 클래스인 Person이 나오는 이유가 뭘까?

만약에 Hong 객체가 하나가 아닌 요소가 100개인 배열로 생성된다고 가정해보자.
그렇다면 힙 영역에 생기는 Hong 객체는 100개가 되고, test() 메서드도 객체 개수에 따라 100개가 된다.
객체 멤버 메서드는 각 객체별로 구현이 달라지는 것이 아니라, 단순히 메서드에서 사용되는 속성의 값만 달라질 뿐이다.
즉, 똑같은 구현의 메서드를 100개를 추가로 생성하는 것은 심각한 메모리의 낭비다.
그래서 JVM은 객체 멤버 메서드 test()를 **스태틱 영역**에 단 하나만 보유한다. 그리고 test() 메서드를 호출할 때
객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.




