# 목차

- [목차](#목차)
- [1. 트랜잭션과 락](#1-트랜잭션과-락)
  - [1.1 트랜잭션과 격리 수준](#11-트랜잭션과-격리-수준)
    - [READ UNCOMMITED](#read-uncommited)
    - [READ COMMITED](#read-commited)
    - [REPEATABLE READ](#repeatable-read)
    - [SERIALIZABLE](#serializable)

# 1. 트랜잭션과 락

## 1.1 트랜잭션과 격리 수준

트랜잭션은 ACID를 보장해야 한다.

- Atomic : 원자성
- Consistency : 일관성
- Isolation : 격리성
- Durability : 지속성


1. **원자성**

트랜잭션 내에서 실행한 작업은 전부 성공하거나 전부 실패해야 한다.

2. **일관성**

모든 트랜잭션은 데이터베이스 내에서 일관성을 유지해야 한다.

3. **격리성**

동시에 실행되는 트랜잭션들이 서로 영향을 끼치지 못하도록 격리해야 한다.

4. **지속성**

트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.


> 여기서 문제가 되는 것은 격리성인데, 트랜잭션 간 완벽한 격리성을 보장하려면
트랜잭션을 거의 순서대로 실행해야 한다. 이렇게 하면 동시성 처리 성능이 매우 나빠진다.

이런 문제로 트랜잭션의 격리 수준은 4단계로 나뉜다. 아래로 갈수록 격리 수준이 높아진다.

### READ UNCOMMITED

- 커밋하지 않은 데이터를 읽을 수 있다.
- 예를 들어 트랜잭션1이 데이터를 수정하고 커밋하지 않아도 트랜잭션2가 수정중인 데이터를 읽을 수 있다.(**DIRTY READ**)
- 따라서 데이터 정합성에 심각한 문제가 발생할 수 있다.

### READ COMMITED

- 커밋한 데이터만 읽을 수 있으므로 DIRTY READ 는 발생하지 않는다.
- 트랜잭션 1이 회원 A를 조회중인데 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회했을 때
수정된 데이터가 조회된다(**NON-REPEATABLE READ**)

### REPEATABLE READ

- 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
- 트랜잭션 1이 10살 이하의 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션 1이 재조회했을 때
결과 집합이 달라진다.(**PHANTOM READ**)

### SERIALIZABLE

- 가장 엄격한 트랜잭션 격리 수준이다.
- PHANTOM READ 도 발생하지 않는다.
- 하지만 처리 성능은 급격하게 떨어질 수 있다.

애플리케이션 처리 대부분은 동시성 처리가 중요하므로 **READ COMMITED** 격리 수준을 기본으로 사용한다.
더 높은 격리 수준을 원하면 데이터베이스 트랜잭션이 제공하는 잠금 기능을 사용하면 된다.



