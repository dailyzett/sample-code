## 객체 지향 설계 5원칙

### 1. 개요

객체 지향 설계 5원칙으로 불리는 SOLID는 다음과 같이 5개로 나뉜다.

- SRP(Single Responsibility Principle) : 단일 책임 원칙
- OCP(Open Closed Principle) : 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle) : 의존 역전 원칙

SOLID 원칙은 객체를 설계할 때 응집도는 높이고 결합도는 낮추는 고전 원칙을 재정립한 것이라 볼 수 있다.

> Note.<br>
> 결합도 : 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 유지 보수가 용이하다.
> <br>
> 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들이 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나
> 유지 보수가 용이하다.

### 2. SRP - 단일 책임 원칙

> 클래스는 하나의 책임만 가져야한다.

SRP를 통해 얻을 수 있는 이점은 다음과 같다.

- 테스트 : 클래스가 단 하나의 책임만 맡고 있기 때문에 테스트 케이스 작성이 쉬워진다.
- 낮은 결합성 : 단일 클래스의 기능이 적어질수록 결합도는 낮아진다.

단일 책임 원칙을 지키지 않았을 때 가장 많이 보이는 코드는 **if 분기문**이다.

```java
class Dog{
    final static Boolean male = true;
    final static Boolean female = false;
    Boolean gender;
    
    void pee(){
        if(this.gender = male){
            // 한쪽 다리를 들고 소변을 본다.
        }else{
            // 뒷다리를 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }
}
```

예제를 보면 필드값이 male이냐 female이냐에 따라서 if문으로 분기가 되고 있다.
이 메서드는 성별에 따른 메서드의 행동을 전부 구현하기 위해 단일 책임 원칙을 위반하고 있는 경우이다.
따라서 같은 클래스 내에 male과 female 속성을 두는 것이 아니라 상위 클래스로 추상 클래스를 선언하고
추상 클래스를 상속받는 형태의 코드가 옳다.

```java
abstract class Dog{
    abstract void pee();
}

class male extends Dog{
    void pee(){
        //TODO
    }
}

class female extends Dog{
    void pee(){
        //TODO
    }
}
```

코드를 이와 같이 작성했을 때 더 이상 성별에 따른 if 분기가 필요하지 않다.

### 2. OCP - 개방 폐쇄 원칙

> 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

개방 폐쇄 원칙을 가장 잘 나타나는 예시는 JDBC이다.

![](https://images.velog.io/images/dailyzett/post/3e3fd7e3-91d6-4ac2-b859-f45afcb01723/007.png)

JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection 설정을 하는 것 외의 코드는
따로 건들일 필요가 없다. Connection 설정마저도 web.xml과 같은 별도의 설정파일에 저장해두면 자바 클라이언트 코드는
단 한 줄도 변경하지 않아도 된다. JDBC 뿐만 아니라, iBatis, MyBatis, 하이버네이트 등등 데이터베이스 프로그래밍을 지원하는 라이브러리나
프레임워크에도 개방 폐쇄 원칙이 적용되어 있다.

위의 개념에서 **자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다** 라고 했다.
JDBC에서, 확장은 **데이터베이스를 교체한다는 것**을 뜻한다.
변경은 **자바 애플리케이션이 데이터베이스라고 하는 변화에 닫혀있는 것**을 뜻한다.
정리하면, JDBC는 데이터베이스가 자신을 교체(확장)하는 것에는 열려있지만, 자바 애플리케이션은 데이터베이스라는 주변의 변화에 닫혀 있는 것이다.

이런 특성은 자바 자체에도 적용되어 있다. 개발자가 자바 코드를 작성하면 운영체제가 무엇이든지 실행 가능하다.
이것이 가능한 이유는 각 운영체제별 JVM과 목적 파일(.class)이 있기에 다양한 구동 환경에 대해서 걱정하지 않아도 되기 때문이다.
개방 폐쇄 원칙을 이용해 해석하면, 
개발자가 작성한 소스코드는 **운영체제의 변화**에 닫혀 있고, **각 운영체제별 JVM은 확장**에 열려 있는 구조가 되는 것이다.

### 3. LSP - 리스코프 치환 원칙

> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야한다.

객체 지향에서 상속은 조직도나 계층도가 아닌 **분류도**가 되어야 옳다.
보통 추상 클래스나 인터페이스를 적용해서 코드를 작성하면 다음 두 가지 형태 중 하나가 된다.

- 하위 클래스 is kind of 상위 클래스
- 구현 클래스 is able to 인터페이스

위 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙은 잘 지켜고 있다고 할 수 있다.
하지만 위 문장대로 구현되지 않은 코드가 존재할 수 있는데, 상속이 조직도나 계층도 형태로 설계된 형태이다.

```java
Parent james = new child();
```

위 코드는 우리가 부모(Parent)클래스와 자식(Child)클래스 대신 상위 클래스와 하위 클래스로 불러야하는 또 다른 이유가 된다.
상위 클래스의 객체 참조 변수에는 하위 클래스의 인스턴스 할당이 가능하다. 하지만 이렇게 되면 논리적인 오류가 생긴다.
james는 Parent형의 객체 참조 변수이기 때문에 Parent(부모)가 가진 행동(메서드)을 할 수 있어야하는데 james가 그의 자식이라는 이유만으로,
아버지의 모든 역할을 할 수 있어야 된다는게 논리에 맞는가?

조직도나 계층도로 클래스가 설계되면 논리적인 오류가 생길 수 밖에 없고, 이 오류는 서브 타입이 항상 자신의 기반 타입으로 교체될 수 있어야 한다는
리스코프 치환의 법칙에 위배된다. 조금만 생각해봐도 자식이 아버지가 하는 역할과 책임을 모두 맡기란 무리기 때문이다.

따라서 클래스를 설계할 때는 다음과 같이 분류도 형태로 설계해야 한다.

```java
동물 뽀로로 = new 펭귄();
```

분류도 형태로 설계하면 논리적인 흠이 없다. 펭귄이 새로 태어났을 때, 그 펭귄을 뽀로로라고 이름을 짓는다. 그리고 그 뽀로로는 동물의 행동(메서드)
를 하는 것이 당연하다. 로버트 C 마틴이 리스코프 치환 법칙에 대해서 말한 것을 의역해보자.

> 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.

말이 길어졌지만 가장 위에 소개했던 개념과 같은 맥락이다.


### 4. ISP - 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.

단일 책임 원칙은 클래스가 많은 역할을 담당하고 있다면 각 역할에 맞게 클래스를 분할하는 방법이었다.
인터페이스 분리 원칙은 클래스를 분할하는 것보단, 중간에 완충 장치를 하는 인터페이스를 여러개 추가해
그 역할을 제한하는 방법이다. 따라서 단일 책임 원칙과 인터페이스 분리 원칙은 같은 문제에 대한 두 가지 다른 해결책이라고
볼 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.

인터페이스 분할 원칙과 항상 함께 등장하는 원칙 중 하나로 **인터페이스 최소주의 원칙**이 있다.
인터페이스를 통해 메서드를 제공할 때는 최소한의 메서드만 제공하라는 것이다. 클래스 상속과 인터페이스 구현에 있어서
상위 클래스는 풍부한 것이 좋고 인터페이스는 작을수록 좋다. 다음 그림을 보자.

![](https://images.velog.io/images/dailyzett/post/57dbcb30-f022-4739-89b6-af9791c2d357/015.png)

상위 클래스가 빈약한 경우 같은 속성인 생일, 주민등록번호와 같은 메서드인 자다()와 소개하다()를 공통적으로 가지고 있다.
이러면 코드 수정이 필요할 때 두 개의 클래스에 일일이 들어가야되기 때문에 유지 보수하기가 까다로워진다.
하지만 상위 클래스가 풍부한 경우, 중복되는 속성과 메서드는 모두 상위 클래스에 선언되어있기 때문에 코드도 간결해지고 유지 보수도 쉬워진다.
그리고 현재 소개하다() 메서드는 학생과 군인 클래스에 따라 행동을 달리 해야하는데 사람 클래스에 속해있다. 이럴 때는 추상 메서드를 사용하면 된다.

### 5. DIP - 의존 역전 원칙

> 고차원 모듈은 저차원 모듈에 의존하면 안 된다.
> 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.

> 추상화된 것은 구체적인 것에 의존하면 안 된다.
> 구체적인 것이 추상화된 것에 의존해야 한다.

> 자주 변경되는 구체(Concrete) 클래스에는 의존하지 마라

의존 역전 원칙을 적용하지 않은 구체 클래스에 의존하는 클래스의 그림을 보자.

![](https://images.velog.io/images/dailyzett/post/14ebf370-71ac-4d41-9a62-97737a5d578e/016.png)

자동차는 몇 년에 한 번 바뀔까 말까인데 스노우타이어는 겨울, 그것도 눈이 오지 않거나 빙판길을 달려야하는 특수한 상황이 아니라면
타이어를 교체해야한다. 즉, 자동차 자신보다 더 자주 변경되는 클래스에 의존하고 있기 때문에 이것은 잘못된 객체 지향 설계이다.
이 그림을 다시 설계하면 다음과 같이 변경 가능하다.

![](https://media.vlpt.us/images/dailyzett/post/66b2b038-a7e6-4e78-91e3-c34d9e896354/017.png)

추상화된 타이어 인터페이스에만 의존하게 함으로써 다른 구체적인 타이어로 변경되어도 자동차는 이제 그 영향을 받지 않는다.
그런데 그림을 보면 인터페이스라는 완충 장치를 중간에 둬서 확장에는 열려있고 변경에는 닫혀있는 **개방 폐쇄 원칙**이 떠오른다.
실제로 객체 지향 설계를 할 때 하나의 해결책을 찾으면 그 안에 여러 설계 원칙이 녹아있는 경우가 많다.

처음 그림에서, 스노우 타이어는 무엇에도 의존하지 않는 클래스였다. 하지만 그 다음 그림에서는 추상적인 타이어 인터페이스에 의존하게 되었다.
**의존 방향이 역전된 것이다.** 이처럼 자신보다 변하기 쉬운 클래스에 의존하던 것을 중간에 추상화된 인터페이스나 상위 클래스를 두어 **변하기 쉬운
것에 영향받지 않도록 하는 것**이 의존 역전 원칙이다.

### 6. 정리

마지막으로 정리하면 SOLID 원칙의 각 철자는 다음과 같다.

> S : SRP - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

> O : OCP - 자신의 확장에는 열려 있고, 주변의 변경에는 닫혀 있다.

> L : LSP - 하위 클래스는 언제나 상위 클래스로 교체할 수 있어야 한다.

> I : ISP - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

> D : DIP - 자신보다 변경되기 쉬운 것에 의존하지 마라.

### 7. 참고 자료

> (서적)스프링 입문을 위한 자바 객체 지향의 원리와 이해 - 05. 객체 지향 설계 5원칙

> https://www.baeldung.com/solid-principles








