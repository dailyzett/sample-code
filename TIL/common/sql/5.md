# 목차

- [목차](#목차)
- [1. 개요](#1-개요)
- [2. 시퀀스 객체](#2-시퀀스-객체)
  - [2.1 시퀀스 객체의 문제점](#21-시퀀스-객체의-문제점)
    - [2.1.1 시퀀스 객체로 발생하는 성능 문제](#211-시퀀스-객체로-발생하는-성능-문제)
    - [2.1.2 시퀀스 객체로 발생하는 문제 대처](#212-시퀀스-객체로-발생하는-문제-대처)
      - [CACHE](#cache)
      - [NOORDER](#noorder)
    - [2.1.3 순번을 키로 사용할 때의 성능 문제](#213-순번을-키로-사용할-때의-성능-문제)
    - [2.1.4 순번을 키로 사용할 때의 성능 문제에 대처](#214-순번을-키로-사용할-때의-성능-문제에-대처)
      - [역 키 인덱스](#역-키-인덱스)
      - [복잡한 값 추가](#복잡한-값-추가)
  - [3. IDENTITY 필드](#3-identity-필드)
  - [4. 채번 테이블](#4-채번-테이블)

# 1. 개요

표준 SQL에는 순번을 다루는 기능으로 시퀀셜 객체, IDENTITY 필드가 존재한다.
**결론만 말하자면 이 두 개의 기능 전부 사용하지 않는 것이 낫다.**

그래도 사용하려면 IDENTITY 필드보단 시퀀스 객체 사용을 추천한다.

# 2. 시퀀스 객체

> 시퀀스는 테이블 또는 뷰처럼 스키마에 존재하는 객체 중 하나이다.

```sql
CREATE SEQUENCE testseq
START WITH 1
INCREMENT BY 1
MAXVALUE 100000
MINVALUE 1
CYCLE;
```

이 기능은 INSERT 구문 내부에서 자주 사용된다.
시퀀스 객체로 만들어진 순번을 기본 키로 사용해 레코드를 INSERT 한다.

```sql
INSERT INTO exampleTbl VALUES(NEXT_VALUE FOR nextval, 'a', 'b'...);
```

## 2.1 시퀀스 객체의 문제점

1. 표준화가 늦어서 구현에 따라 구문이 달라 이식성이 없고 사용할 수 없는 구현도 있다.
2. 시스템에서 자동으로 생성되는 값이므로 실제 엔티티 속성이 아니다.
3. **성능적인 문제를 일으킨다.**

1번과 2번은 상황에 따라 그냥 사용하면 그만이지만 3번 문제는 간과할 수 없는 문제다.

### 2.1.1 시퀀스 객체로 발생하는 성능 문제

시퀀스 객체가 생성하는 순번은 세 가지 특성을 가진다.

- 유일성 : 중복값이 생성되지 않는다.
- 연속성 : 생성된 값에 비어있는 부분이 없다.
- 순서성 : 순번의 대소 관계가 역전되지 않는다.

시퀀스 객체는 기본 설정에서 이 세가지 속성을 전부 만족하는 순번을 생성하기 때문에,
동시 실행 제어를 하기 위한 락 메커니즘이 필요하다.

예를 들어 이런 식이다.

1. 시퀀스 객체에 베타 락을 적용
2. NEXT VALUE 검색
3. CURRENT VALUE 1만큼 증가
4. 베타 락 해제

1~4 단계에서 다른 사용자는 시퀀스 객체에 접근 불가능하다.
따라서 동시에 여러 사용자가 시퀀스 객체에 접근하는 경우 락 충돌로 인한 성능 문제가 발생한다.

### 2.1.2 시퀀스 객체로 발생하는 문제 대처

문제를 완화하는 방법으로 _CACHE_ 와 _NOORDER_ 객체가 있다.

#### CACHE

> 새로운 값이 필요할 때마다 메모리에 읽어들일 필요가 있는 값의 수를 설정한다.

접근 비용을 줄일 수 있지만 시스템 장애가 발생할 경우 연속성을 보장하지 못한다.
따라서 장애가 발생하면 비어있는 숫자가 생긴다.

#### NOORDER

> 순서성을 담보하지 않아서 오버헤드를 줄일 수 있다.

다만 순서성을 담보하고 싶을 땐 사용하지 못한다.

### 2.1.3 순번을 키로 사용할 때의 성능 문제

> 시퀀스 객체가 성능 문제를 일으키는 두 번째 경우는 **핫 스팟**과 관련되어 있다.

- 이것은 DBMS의 물리적인 저장 방식 때문에 발생한다.
- 순번처럼 비슷한 데이터를 연속으로 INSERT 하면 물리적으로 같은 영역에 저장된다.
- 이 때 저장소의 특정 물리적 부분에만 I/O 부하가 커지므로 성능 악화가 발생한다.

DBMS는 물리적인 계층을 사용자로부터 은폐하는 것이 기본이므로 이런 문제에 대처하기는 거의 불가능하다.

### 2.1.4 순번을 키로 사용할 때의 성능 문제에 대처

#### 역 키 인덱스

> 연속된 값을 도입하는 경우라도 DBMS 내부에 변화를 주어 제대로 분산할 수 있는 구조를 사용하는 방법이다.

**한계:**

- INSERT 구문 자체는 빨라지나 범위 검색에서 I/O 양이 늘어나므로 SELECT 구문의 성능이 나빠질 수 있다.
- 구현 의존적인 방법이다.

#### 복잡한 값 추가

> 인덱스에 일부러 복잡한 필드를 추가해서 데이터의 분산도를 높이는 방법이다.

- 인덱스에 불필요한 키를 추가한다는 것은 좋은 설계 방법이 아니다.
- 다른 개발자가 봤을 때 "이 테이블의 인덱스는 무슨 목적으로 생성한거지?" 라고 생각할 수 있다.

시퀀스 객체를 사용했을 때 발생하는 성능 문제는 매우 뿌리깊다.
따라서 최대한 사용하지 않는 것이 낫다.


## 3. IDENTITY 필드

IENTITY 는 시퀀스 객체보다 문제가 더 심각하다.

- 기능적으로 시퀀스 객체는 테이블과 독립적이므로 여러 테이블에서 사용 가능하다.
- 반대로 IDENTITY 필드는 테이블과 연결된다.
- 시퀀스 객체는 CACHE, NOORDER를 지정할 수 있지만 IDENTITY 필드는 이런 것도 없다.

따라서 IDENTITY 필드를 기본 키로 사용한다는 것은 장점이 거의 없다고 봐도 무방하다.

## 4. 채번 테이블

옛날에 만들어진 애플리케이션에서는 채번 테이블이라는 순번을 생성하는 전용 테이블을 사용하는 경우가 있었다. 
물론 성능은 제대로 나오지 않는다. 오라클의 CACHE, NOORDER 도 물론 사용하지 못하므로 사용할 이유가 없다.

