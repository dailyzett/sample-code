## 동시성 문제를 해결하기 위해 자바에서 제공하는 것들

### 1. 개요

Java는 동시성 문제를 해결하기 위해 다음 방법들을 제공한다.

- Synchronized
- Atomic
- Volatile

각 특성들을 알아보자.

### 2. Synchronized

synchronized 키워드는 메서드 혹은 블록에만 적용 가능하고 변수의 적용은 불가능하다.
멀티 쓰레드 환경일 때 각 쓰레드가 동일한 객체에 접근했을 때, 데이터 불일치 문제가 발생할 수 있다.
이 때 synchronized 키워드를  메서드나 블록에 적용하면 다른 쓰레드가 접근할 수 없게 할 수 있으므로 데이터 불일치 문제를
해결할 수 있다. 하지만 이것은 단점으로도 작용한다. 다른 쓰레드가 접근하는 것을 일단 막고 보기 때문에,
 자원을 점유하고 있는 쓰레드의 작업이 끝날 때까지 다른 쓰레드는 무작정 대기해야만 한다. 그리고 이것은 성능문제를
야기시킨다.

따라서 해당 키워드를 꼭 사용해야한다면 모든 블록을 synchronized 키워드로 적용하는 것이 아닌,
반드시 동기화를 적용해야만 하는 영역(critical section)에만 적용하는 것이 옳다. 


### 3. Volatile Modifier

volatile은 변수 단위에서 동기화를 적용할 수 있게 해준다. 변수에만 적용가능하고 다른 곳의 적용은 불가능하다. 
멀티 쓰레드 환경에서 volatile로 선언되지 않은 변수가 사용될 때, 성능을 높이기 위해 값을 메인 메모리로부터 **CPU 캐시**로 복사해 사용한다.
그림으로 보면 다음과 같다.

![volatile img](http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png)

멀티 쓰레드 환경에서 volatile이 아닌 변수를 사용하면 **CPU 캐시에서 메인 메모리로 데이터를 쓰거나
메인 메모리에서 CPU 캐시로 데이터를 읽는 시기**에 대한 보장이 없다. 이로 인해 문제가 발생할 수 있는데,
다음 상황을 살펴보자

- 쓰레드 1은 count 변수를 증가시키는 로직을 가지고 있지만 쓰레드 2는 가지고 있지 않다.
- 하지만 쓰레드 1과 2는 모두 count 변수에 접근할 수 있다.

```java
public class SharedObject{
    public int count = 0;
}
```

쓰레드 1에서 증가시킨 count 변수가 메인 메모리로 가기를 원하지만, 
이 상황에서는 CPU 캐시에 있는 데이터가 메인 메모리에 쓰여지는 시기는 아무도 모른다.
따라서 쓰레드 1이 변수 값을 최신화시켜도 쓰레드 2는 이 값을 전혀 참조하지 못하는 결과가 발생한다.
이러한 상황을 **가시성(visibility)** 문제가 발생했다고 표현한다. 

![volatile exam](http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png)

이 문제를 해결하기 위해서 다음과 같이 변수에 volatile를 사용할 수 있다.

```java
public class SharedObject{
    public volatile int count = 0;
}
```

volatile 변수는 쓰기와 읽기를 모두 메인 메모리에서 처리할 수 있도록 보장한다.
즉, volatile은 **가시성**을 보장한다고 말할 수 있다.

#### 3.1 volatile 사용을 지양해야하는 환경

volatile 변수는 메인 메모리에서 값을 가져오기 때문에 가시성을 보장함에도 불구하고 쓰지 말아야할 환경이 있다.
앞의 상황에서, 쓰레드 1만 count 변수에 값을 썼기 때문에 쓰레드 2는 항상 최근 값을 볼 수 있었다.
하지만 쓰레드 1과 쓰레드 2 모두가 공유 변수(여기서 count 변수)에 읽고 쓰는 상황이 된다면 이야기가 달라진다.
어떤 쓰레드가 먼저 volatile 변수를 읽은 후, 값을 쓰기 전에 
다른 쓰레드가 volatile 변수값을 읽어와 새로운 값을 쓰는 것이 가능하다.

예를 들어, 개발자가 생각한 로직이 만약 다음과 같다고 생각해보자

- 쓰레드 1이 count 변수를 0에서 1로 증가시킨다.
- 이 count 변수를 메인 메모리에 저장한다.
- 쓰레드 2가 count 변수를 메인 메모리에서 가져와 1에서 2로 증가시킨다
- 이 count 변수를 다시 메인 메모리에 저장한다.

하지만 volatile 변수는 이렇게 작동하리라고 반드시 보장하지 않는다. 예를 들면 다음과 같은 상황이 올 수도 있다.

- 쓰레드 1이 count 변수를 0에서 1로 증가시킨다.
- 하지만 쓰레드 1이 CPU 캐시에서 메인 메모리로 값을 옮기지 않은 상태이다.
- 이 상태에서, 쓰레드 2가 메인 메모리에서 count 변수를 가져온다. 쓰레드 2도 가져오는 값은 0이다.
- 쓰레드 2가 count 변수를 0에서 1로 증가시킨다.

이것은 개발자가 예상한 결과를 크게 벗어난다. 쓰레드 1과 쓰레드 2는 사실상 동기화가 되지 않은 상태이다.
이 상태에서 쓰레드 1이 count 변수를 메인 메모리에 넣는다 한들 예상한 결괏값과는 틀릴 것이 뻔하다.

다음 그림은 예시를 설명한 그림이다.

![3.1 volatile](http://tutorials.jenkov.com/images/java-concurrency/java-volatile-3.png)

#### 3.2 volatile을 사용해야하는 환경

위에서 보다시피 volatile은 두 개의 쓰레드가 공유 변수를 읽고 쓰는 중이라면 동기화를 보장하지 않는다.
위의 상황이라면 중요한 섹션에 synchronized 키워드를 사용하거나 java.util.concurrent 패키지의 AtomicXXX 데이터 유형 중 하나를
사용해야한다.

volatile 변수는 하나의 쓰레드에서는 값을 쓰거나 읽지만, 다른 쓰레드에서는 그 값을 읽기만 할 때
항상 최신 값을 볼 수 있기 때문에 유용하게 사용할 수 있다.

#### 3.3 volatile 의 성능

volatile은 메인 메모리에서 값을 저장하거나 불러온다. 메인 메모리의 읽기, 쓰기 작업은
CPU 캐시에서 접근하는 것보다 많은 비용이 든다. 즉, volatile 을 너무 남발하면 성능이 떨어질 수 있기 때문에
반드시 가시성을 보장해야하는 변수에만 사용해야한다.


### 4. Atomic 변수

Java에서 주로 사용되는 Atomic 변수 클래스는 다음 4가지이다.

- AtomicInteger
- AtomicLong
- AtomicBoolean
- AtomicReference

Atomic 변수는 내부적으로 Atomic 연산을 수행해서 데이터 무결성을 보장한다.

#### 4.1 Atomic 연산

동기화를 위해 synchronized 를 사용해서 다른 쓰레드의 접근을 막아버리면 성능에 악영향을 끼친다.
그래서 개발자들은 멀티 쓰레드 환경에서 다른 쓰레드를 차단하지 않으면서(non-blocking) 데이터 무결성을 보장하는 방법을 생각해냈는데
그것이 **CAS(Compare And Swap)** 이다.

CAS 연산은 세 개의 피연산자에서 작동한다.
- M : 작동할 메모리 위치
- A : 변수의 기존 기대값
- B : 설정해야 하는 새로운 값

CAS 연산은 **M(작동할 메모리 위치)** 의 값을 **B(설정해야 하는 새로운 값)** 으로 원자적으로 업데이트를 한다.
하지만 M의 기존 값이 **A(변수의 기존 기대값)** 과 일치하는 경우에만 업데이트되고, 그렇지 않으면 아무런 행동도 하지 않는다.
여러 쓰레드가 CAS 연산으로 동일한 값을 업데이트하려고 하면 그 중 하나의 쓰레드만 값을 업데이트한다. 여기서 synchronized 키워드와 다른 점은
다른 쓰레드가 일시 정지가 되지 않는다는 점이다. 대신 값을 업데이트하지 못했다는 알림을 받게 된다. 그 후 쓰레드는 추가 작업을 계속할 수 있다.

> 요약.<br>
> CAS 알고리즘은 변수의 실제 값을 변수의 예상 값과 비교하고 실제 값이 예상 값과 일치하면 전달된 새 값으로
> 변수의 실제 값을 바꾸는 것이다.

다만 Atomic 연산의 한 가지 단점은 프로그램의 논리가 조금 더 복잡해질 수 있다. CAS 작업이 성공하지 못했을 때의 경우를 처리해야되기 때문이다.
이 때 개발자는 성공할 때까지 계속해서 다시 시도하거나 아무 것도 하지 않고 작업을 계속 진행하도록 할 수 있다.

#### 5. 참고 자료


> https://www.geeksforgeeks.org/java-program-to-implement-cas-compare-and-swap-algorithm/

> https://www.baeldung.com/java-atomic-variables

> http://tutorials.jenkov.com/java-concurrency/volatile.html

