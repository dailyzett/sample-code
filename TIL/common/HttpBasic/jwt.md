# 목차

- [목차](#목차)
- [1. JSON Web Token 은 무엇인가?](#1-json-web-token-은-무엇인가)
- [2. JSON Web Token 은 언제 사용할까?](#2-json-web-token-은-언제-사용할까)
- [3. JWT의 구조](#3-jwt의-구조)
- [4. JWT의 동작 방식](#4-jwt의-동작-방식)
- [5. 왜 JWT 를 사용해야 하는가?](#5-왜-jwt-를-사용해야-하는가)

# 1. JSON Web Token 은 무엇인가?

- JWT는 정보를 JSON 오브젝트로 안전하게 전송하기 위한 간결하고 자체 포함된
방법을 정의하는 개방형 표준(RFC 7519)
- JWT는 HMAC 알고리즘을 사용하는 비밀 키, RSA 또는 ECDSA를 사용하는
  공개/개인 키 쌍을 사용하여 서명할 수 있다.

서명된 토큰은 그 안에 포함된 정보의 무결성을 확인할 수 있는 반면
암호화된 토큰은 이러한 정보를 다른 클라이언트(ex. 공격자)로부터 숨길 수 있다. 공개/개인 키 쌍을 사용하여 토큰에 서명할 때 서명은 개인 키를 보유하고 있는 당사자만 서명했음을 증명한다.


# 2. JSON Web Token 은 언제 사용할까?

> **Authorization**

사용자가 로그인하면 각 후속 요청에는 JWT가 포함되어 사용자가 해당 토큰으로
허용되는 경로, 서비스 및 리소스에 액세스할 수 있다.

> **Information exchange**

JWT는 당사자 간의 정보를 안전하게 전송할 때 사용할 수 있다.
공개/개인 키 쌍을 사용하여 JWT에 서명할 수 있기 때문에 보내는 사람이 누구인지 확인할 수 있다. 또한 헤더와 페이로드를 사용해서 시그니처를 계산하므로 콘텐츠가 변조되지 않았는지 확인할 수도 있다.


# 3. JWT의 구조

간결한 형태의 JSON 웹 토큰은 점(.)으로 구분된 세 부분으로 구성되며
다음과 같다.

- Header
- Payload
- Signature

그러므로 JWT는 일반적으로 다음과 같이 보인다.

```text
xxxxx.yyyyy.zzzzz
```

> **Header**

헤더는 두 개의 파트를 포함한다.
토큰 타입과 서명하기 위해 적용된 사용된 알고리즘 종류이다.

```text
{
    "alg" : "HS256",
    "typ" : "JWt"
}
```


> **Payload**

토큰의 두 번째 부분이다. 클레임 엔티티 및 추가 데이터에 대한 설명이 들어 있다. 클레임에는 등록된 클레임, 공개 클레임 및 비공개 클레임의 세 가지 타입이 존재한다.


- Registered claims(등록된 클레임)
  - 필수는 아니지만 유용하고 상호 운용 가능한 클레임 집합을 제공하기 위해 권장되는 미리 정의된 클레임 집합이다.
  - iss(발급자), exp(만료 시간), sub(주제), aud(청중) 및 기타로 이루어져 있다.
- Public claims(공개 클레임)
  - JWT를 사용하는 사람들이 마음대로 정의할 수 있다.
  - 그러나 충돌을 방지하려면 IANA JSON Web Token 레지스트리에 정의하거나 충돌 방지 네임스페이스를 포함하는 URI로 정의해야 한다.
- Private claims(비공개 클레임)
  - 사용에 동의하고 등록된 클레임이나 공개 클레임이 아닌 당사자 간에 정보를 공유하기 위해 생성된 맞춤 클레임이다.


```text
{
    "sub": "123456",
    "name": "park",
    "admin": true
}
```

서명된 토큰의 경우 정보는 변조로부터 보호되지만 누구나 읽을 수 있다.
암호화되지 않은 경우 JWT의 페이로드 또는 헤더 요소에 민감한 정보를 넣어선 안 된다.

> **Signature**

시그니처 파트를 만들기 위해 인코딩된 헤더, 인코딩된 페이로드, 암호, 헤더에 지정된 알고리즘을 가져와야 한다.

예를 들어 _HMAC SHA256_ 알고리즘을 사용하려는 경우 시그니처는 다음과 같은 방식으로 생성된다.

```text
HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret)
```

시그니처는 메시지가 도중에 변경되지 않았는지 확인하는 데 사용되며 개인 키로 서명된 토큰의 경우 JWT의 보낸 사람이 누구인지 확인할 수도 있다.

위 내용을 바탕으로 JWT 토큰을 생성하면 다음과 같다.

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTYiLCJuYW1lIjoicGFyayIsImFkbWluIjp0cnVlfQ.TOE8Gfe8_n_Tj2H3cBQttAiy4AfIpNYElLV1yA3xWTk
```

JWT 토큰의 디버깅은 https://jwt.io/#debugger-io 에서 확인 가능하다.

# 4. JWT의 동작 방식

인증 과정에서 사용자가 자격 증명을 사용하여 성공적으로 로그인하면 JWT가 반환된다. 토큰은 자격 증명이므로 필요 이상 오래 보관하면 보안 문제가 발생할 수 있다. 또한 보안이 취약하므로 민감한 세션 데이터를 브라우저 저장소에 저장해서는 안 된다.

사용자가 보호된 경로 또는 리소스에 액세스하려고 할 때마다 유저 에이전트는 일반적으로 _Bearer schema_ 를 사용하여 _Authorization header_ 에서 JWT를 전송해야 한다. 헤더 내용은 다음과 같다.

```text
Authorization: Bearer <token>
```

이것은 사용자 상태가 서버 메모리에 저장되지 않기 때문에 무상태 인증 메커니즘이다. 서버의 보호된 경로는 _Authorization header_ 에서 유효한 JWT를 확인하고 존재하는 경우 사용자가 허용된다. 그리고 JWT에는 필요한 모든 정보가 있으므로 데이터베이스 앞뒤를 이동할 필요가 줄어든다.

![img_7.png](img_7.png)


1. 애플리케이션 혹은 클라이언트는 권한 부여 서버에 권한 부여를 요청한다.
   이것은 다른 권한 부여 흐름 중 하나를 통해서 수행된다.
   예를 들어, 일반적인 _OpenID Connect_ 호환 웹 애플리케이션은 인증 코드 흐름을 사용하여 _/auth/authorize_ 끝점을 통과한다.

2. 권한이 부여되면 권한 서버는 애플리케이션에 액세스 토큰을 반환한다.
3. 애플리케이션은 액세스 토큰을 사용해서 권한이 필요한 리소스에 접근할 수 있다.

서명된 토큰을 사용하면 토큰에 포함된 모든 정보를 변경할 수 없더라도
사용자 또는 다른 사람에게 노출된다. 즉, 토큰 안에는 비밀 정보를 넣어선 안 된다.

**클라이언트가 POST 요청을 보냈을 때 JWT의 동작 방식:**

![img_10.png](img_10.png)


# 5. 왜 JWT 를 사용해야 하는가?

SWT와 SAML과 비교했을 때 JWT의 이점은 여러가지가 있다.

1. JSON은 XML보다 덜 장황하기 때문에 인코딩될 때 크기도 작아져 SAML보다 훨씬 간결해진다. 따라서 JWT는 HTML 및 HTTP 환경에서 전달하기에 좋은 선택이다.

2. 보안 측면에서 SWT는 HMAC 알고리즘을 사용하는 공유된 비밀 키, 즉 대칭 키 암호화 알고리즘을 사용한다. 그러나 JWT 및 SAML 토큰은 서명을 위해 공개/개인 키 쌍을 사용할 수 있다.

3. JSON 파서는 오브젝트에 직접 매핑되기 때문에 대부분의 프로그래밍 언어에서 일반적으로 사용된다. 반대로 XML에는 자연스러운 도큐먼트 vs 오브젝트 매핑이 없다. 이렇게 하면 SAML 보다 JWT로 작업하기가 더 쉽다.

4. 사용에 관해서는 JWT가 인터넷 규모로 사용된다. 이는 여러 플랫폼, 특히 모바일에서 JWT를 사용해 이식성을 높일 수 있다.

**인코딩된 JWT와 인코딩된 SAML 길이 비교:**

![img_8.png](img_8.png)

