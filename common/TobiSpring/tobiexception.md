# 1. 예외

## 1.1. 초난감 예외처리

### 예외 블랙홀

```java
try{
    //TODO
}catch(SQLException e){
}
```

try/catch 블록에서 예외가 발생해도 코드를 계속 동작시킬 것이 아니라면 위 코드는 좋지 않다.
프로그램 실행 중 어디선가 오류가 있어 예외가 발생해도 어디에서 일으켰는지 파악할 수 없기 때문이다.

```java
catch(SQLException e){
    e.printStackTrace();
}
```

이 코드도 마찬가지이다. 출력해봤자 다른 로그나 메시지에 묻혀버리기 쉽상이다.
그리고 화면에 예외 로그를 출력한다고 해서 이것을 예외를 처리했다고 볼 수는 없다.
> 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.

### 무책임한 throws

```java
public void method1() throws Exception{ method2(); }
public void method2() throws Exception{ method3(); }
public void method3() throws Exception{ ... }
```

모든 예외를 이렇게 Exception 처리하는 것도 문제가 있다.
- 단순 복사 붙여넣기식 Exception 이기 때문에, 어떤 예외적인 상황이 발생한다는 것인지 알 수 없다.
- 이 메서드를 호출한 다른 메서드도 똑같이 throws Exception 코드를 복사/붙여넣기 해야한다.

## 1.2 예외의 종류와 특징

### Error

에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 발생한다.
따라서 시스템 레벨에서 특별한 작업을 할 것이 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경쓰지 않아도 된다.

### Exception과 체크 예외

Exception 클래스는 두 가지로 나뉜다.

- checked exception
- unchecked exception

#### unchecked exception

런타임 예외라고도 한다. 런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것이다.
대표적으로 NullPointerException 과 IllegalArgumentException 이 있다.

#### checked exception

IOException 이나 SQLException 을 비롯해서 예외적인 상황에서 던져질 가능성이 있는 것들 대부분은
checkedException 으로 만들어져 있다.

## 1.3 예외 처리 방법

### 예외 복구

네트워크가 불안해서 가끔 서버에 접속이 잘 안되는 환경에 있는 시스템이 있다고 가정한다.
원격 DB 서버에 접속하다 실패해서 SQLException 이 발생하는 경우에 재시도를 시도해볼 수 있다.
정해진 횟수만큼 재시도해서 실패했다면 예외 복구는 포기해야 한다.

### 예외 회피

예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다.
템플릿/콜백 패턴에서 콜백 오브젝트는 자신이 발생한 예외를 자신을 호출한 템플릿에게 던진다.
예외를 처리하는 것은 콜백이 처리해야할 문제가 아니기 때문이다.

하지만 템플리/콜백 처럼 긴밀한 연관 관계가 아닌 이상, 무책임하게 예외를 회피하면 문제가 발생할 수 있다.
DAO 에서 Exception 을 던진다고 해도, 이것을 호출하는 서비스와 컨트롤러에서 해당 예외를 처리할 수 있을 거라는
생각은 들지 않는다. 결국 컨트롤러나 서비스도 예외를 계속 던져서 이 예외는 결국 서버로 전달될 것이다.

예외를 회피하는 것은 예외를 복구하는 것보다 의도가 분명해야 한다.

### 예외 전환

예외를 복구해서 정상적인 상태로 만들 수 없기 때문에 예외를 메서드 밖으로 던지는 것이다.
예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.
예외 전환은 두 가지 특징이 있다.

- 내부에서 발생한 예외를 그대로 던지는 것이 그 예외 상황에 대한 적절한 의미를 부여해주지 못하는 경우,
의미를 분명하게 해줄 예외로 바꿔주기 위해서다.

전환하는 예외에 원래 발생한 예외를 담아서 **중첩 예외**로 만드는 것이 좋다.

```java
public void(User user) throws DuplicateUserIdException, SQLException{
    try{
        //JDBC를 이용해 user 정보 추가하는 코드    
    }catch(SQLException e){
        if(e.getErrorCode() == MysqlErrorNumbers.EP_DUP_ENTRY)
            throw DuplicateUserIdException();
        else
            throw e;
    }
}
```

- 두 번째 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 **포장** 한다.
의미를 명확하게 하려고 다른 예외로 전환하는 게 아니라, 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우 사용한다.

예를 들면 EJBException 이 있다. EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비즈니스 로직으로 볼 때 의미있는 예외가 아니다.
따라서 이런 경우에 런타임 예외인 EJBException으로 포장해서 던지는 편이 낫다.

> 대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공한다.
> 어차피 복구하지 못할 예외라면 코드에서는 런타임 예외로 포장해서 던져버리고, 예외처리 서비스 등을 이용해 자세한 로그를 남기고,
> 관리자에게는 메일 등으로 통보해주고, 사용자에게는 안내 메시지를 보여주는 식으로 처리하는게 바람직하다.


### 애플리케이션 예외

> 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고,
> 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 있다. 이런 예외들을 일반적으로 **애플리케이션 예외**라고 한다.



