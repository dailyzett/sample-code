# 목차

# 1. 고차 함수 정의

> 고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다.

코틀린에서는 람다나 함수 참조를 사용해 함수를 값으로 표현할 수 있다.

표준 라이브러리인 *filter*는 술어 함수를 인자로 받으므로 고차 함수다.

```kotlin
list.filter { x > 0 }
```

## 1.1 함수 타입

함수 타입을 정의하려면,

1. 함수 파라미터의 타입을 괄호 안에 넣고,
2. 그 뒤에 화살표를 추가한 다음,
3. 함수의 반환 타입을 지정하면 된다.

```kotlin
class HigherFunction {
    @Test
    fun test() {
        val sum: (Int, Int) -> Int = { x, y -> x + y }
        val action: () -> Unit = { println(42) }
    }
}
```

이렇게 변수 타입을 함수 타입으로 지정하면 함수 타입에 있는 파라미터로부터 람다의 파라미터 타입을 유추할 수 있다. 따라서 람다 식 안에 굳이 파라미터 타입을 적을 필요가 없다.

널이 될 수 있는 함수 타입 변수를 선언하려면, 함수 타입 전체가 널이 될 수 있는 타입임을 선언하기
위해 함수 타입을 괄호로 감싸고 그 뒤에 `?`를 붙여야 한다.

```kotlin
fun nullFunctionTest() {
    var funOrNull: ((Int, Int) -> Int)? = null
}
```

참고로 위와 아래 코드는 다르다.

```kotlin
fun canReturnNullTest() {
    var canReturnNull: (Int, Int) -> Int? = { x, y -> null }
}
```

- *funOrNull*: 널이 될 수 있는 함수 타입
- *canReturnNull*: 널이 될 수 있는 반환 타입을 갖는 함수 타입

## 1.2 인자로 받은 함수 호출

표준 라이브러리 함수인 *filter*의 인자를 함수로 받아보자.

```kotlin
fun String.filter(predicate: (Char) -> Boolean): String {
    val sb = StringBuilder()

    for (index in indices) {
        val element = get(index)
        if (predicate(element)) sb.append(element)
    }
    return sb.toString()
}
```

```kotlin
@Test
fun test() {
    println("ab1c").filter { it in 'a'..'z' }
}

//abc
```

`a` 부터 `z`까지 문자만을 필터링하는 메서드이다.

- 람다 함수를 인자로 받아 순회한다.
- *predicate*가 *Char*이면 true를 반환한다. 아니면 false를 반환한다.

그래서 결괏값은 숫자 `1`을 제외한 `abc`가 도출된다.

## 1.3 디폴트 값을 지정한 함수 파라미터

코틀린으로 *StringJoiner*를 구현한다고 가정하는데, 추가 요구 사항으로 각각의 요소들을 변환하는 작업을 추가해야될 때.

```kotlin
private fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = "",
        transform: (T) -> String = { it.toString() }
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
```

`transform` 인자를 람다로 받지만 디폴트 값을 설정해줄 수 있다.

```kotlin
fun main() {
    println(letters.joinToString { it.lowercase(Locale.getDefault()) })

    println(letters.joinToString(
            separator = "! ",
            postfix = "! ",
            transform = { it.uppercase(Locale.getDefault()) }))
}

//Alpha, Beta
//Alpha! Beta! 
```

`transform` 인자를 전달하지 않으면 기본적으로 컬렉션의 toString() 작업이 일어난다.

*joinToString*을 호출할 때마다 매번 람다를 넘기면 기본 동작으로도 충분한 데 번거롭기만 한 경우가 많다. 이 때 디폴트 값을 지정해주면 된다.

간혹 널이 될 수 있는 함수 타입을 인자로 받고 싶을 때가 있다. 코틀린은 NPE가 발생할 수 있는 코드는 막아버린다. 따라서 함수 타입이 *invoke()* 메서드를 구현하는
인터페이스라는 사실을 활용해야 한다.

```kotlin
private fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = "",
        transform: ((T) -> String)? = null
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        val str = transform?.invoke(element) ?: element.toString()
        result.append(str)
    }
    result.append(postfix)
    return result.toString()
}
```

세이프 호출자로 널이 아닌 경우에만 람다를 호출하고 아닌 경우에는 `element.toString()`을 적용 한다.

## 1.4 함수를 함수에서 반환

프로그램의 조건에 따라 달라질 수 있는 로직이 있다고 생각해보자. 이럴 때 람다 함수를 반환하는 함수가 유용하다.

예를 들어 웹에서 이름을 찾을 때, 사용자가 입력한 첫 글자와 매칭되는 정보만 화면에 표시해야 될 때, 코드를 작성해보자.

```kotlin
data class Person(
        val firstName: String,
        val lastName: String,
        val phoneNumber: String?
)

class ContractListFilters {
    var prefix: String = ""
    var onlyWithPhoneNumber: Boolean = false

    fun getPredicate(): (Person) -> Boolean {
        val startsWithPrefix = { p: Perseon ->
            p.firstName.startsWith(prefix) ||
                    p.lastName.startsWith(prefix)
        }

        if (!onlyWithPhoneNumber) return startsWithPrefix

        return {
            startsWithPrefix(it) &&
                    it.phoneNumber != null
        }
    }
}
```

`getPredicate()` 함수는 `Person` 데이터 클래스를 받아 *Boolean* 타입을 리턴한다. `->`가 있으므로 함수를 반환하는
함수를 정의한 것이다.

`Person` 의 이름 첫 글자가 `prefix`와 일치할 때 Boolean 타입을 리턴한다. 그리고 이 람다 함수를 `startsWithPrefix`
변수가 받는다.

```kotlin
fun main() {
    val contacts = listOf(
            MyPerson("Dmitry", "Jemerov", "123-4567"),
            MyPerson("Svetlana", "Isakova", null))
    
    val contractListFilters = ContractListFilters()
    
    with(contractListFilters) {
        prefix = "Dm"
        onlyWithPhoneNumber = true
    }
    
    println(contacts.filter(
            contractListFilters.getPredicate()
    ))
}
```

간단한 테스트를 위해 `contractListFilters` 생성자를 "Dm", "true" 로 설정한다.

그리고 컬렉션 리스트의 *filter()*에 우리가 작성한 `getPredicate()` 함수를 넘긴다.

*filter()* 라이브러리 코드는 아래와 같이 술어에 람다 함수를 인자로 넘길 수 있다. 

```kotlin
public inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {
    return filterTo(ArrayList<T>(), predicate)
}
```

## 1.5 람다를 활용한 중복 제거

