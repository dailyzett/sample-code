# 목차

- [목차](#목차)
- [1. 예제](#1-예제)
- [2. 프레임워크](#2-프레임워크)
- [3. 예제 코드](#3-예제-코드)
  - [3.1 Top-down](#31-top-down)
  - [3.2 Bottom-up](#32-bottom-up)

# 1. 예제

- 리트코드 : 계단 오르기 문제

https://leetcode.com/problems/climbing-stairs/

이 문제를 설명하기 이전에 **상태**라는 용어를 정의해야 한다.
DP 문제에서 상태는 시나리오를 설명할 수 있는 변수들의 집합이다.
이러한 변수를 상태 변수라고 한다.

예를 들어 Climbing Stairs 의 모든 시나리오를 설명하려면 현재 단계인 관련 상태 변수가 하나만 있다. 이것을 정수 i로 나타낼 수 있다. *i = 6* 이면 6단계에 있는 상태를 설명하고 있음을 의미한다. *i*의 모든 고유 값은 고유 상태를 나타낸다.

> **관련(relevant)가 의미하는 바는 무엇인가?**  
> <br/>
> 만약 어떤 사람이 계단 위에 있고 10번째 계단을 밟기 위한 방법의 수를 알고싶다고 가정한다. 이 때 그 사람이 현재 어떤 단계에 있는지는 중요하다. 하지만 계단 위에 서 있는 사람의 양말 색깔 같은 정보는 전혀 중요하지 않다.
> 양말 색상을 상태 변수로 포함해봤자, 빨간 양말이든 파란 양말이든 계단을 오르는 방법의 수에는 전혀 관계가 없기 때문이다. 따라서 양말의 색상은 **관련이 없는 변수**라고 할 수 있다. 계단을 오를 방법의 수를 알아내는 측면에서 유일한 관련 변수는 현재 서 있는 계단이 된다.


# 2. 프레임워크

DP 문제를 해결하려면 세 가지를 결합해야 한다.

**1. 주어진 모든 상태에 대한 문제의 답을 계산/포함하는 함수 또는 데이터 구조**

Climbing Stairs 에 대해서, *dp(i)* 가 i<sup>th</sup> 단계까지 올라가는 방법의 수를 반환하는 함수 _dp_ 가 있다고 가정한다.

어떻게 이런 함수가 도출되었는가? 해당 알고리즘 문제는 "꼭대기에 가기 위해 얼마나 많은 방법의 수를 찾을 수 있는지"를 물어보고 있다. 그래서 특정 단계를 도달할 수 있는 방법의 수를 함수로 표현한 것이다.

> 일반적으로 top-down 방식은 재귀 함수와 해시 맵으로 구현되는 반면 상향식은 중첩 for 루프와 배열로 구현된다. 이 함수나 배열을 설계할 때 인자로 전달할 상태 변수도 결정해야 한다. 이 문제는 간단하기 때문에 상태를 설명하기 위해 필요한 것은 현재 _i_ 에 있는 단계를 아는 것이다.


**1. 상태 간 전환에 대한 반복 관계**

*반복 관계(recurrence relation)* 는 서로 다른 상태를 관련시키는 방정식이다. 

- 예를 들어, 30개의 계단을 오를 수 있는 방법의 수를 찾는다고 가정해보자.
  
문제는 한 번에 한 계단을 밟거나 한 번에 두 계단을 밟을 수 있다는 점이다.
이 문제는 논리적으로 30번째 계단으로 올라간다는 것을 의미한다. 따라서 28번째 또는 29번째 계단에 도착했을 때 30번째 계단으로 올라갈 수 있는 방법의 수는 다음과 같이 나타낼 수 있다.

> 28번째 계단까지 올라갈 수 있는 방법의 수 + 29번째 계단까지 올라갈 수 있는 방법의 수

문제는 28, 29 계단을 오르는 길이 얼마나 많은 지 알 수 없다.
그러나 이 논리를 이용해 수식을 도출할 수 있다.

_dp(i) = dp(i-1) + dp(i-2)_

3. **기본 케이스, 무한 반복이 되지 않도록 하기**

방정식을 통해 무작정 루프를 돌리면 음의 무한대까지 계속 반복할 것이다.
이를 방지하기 위해 기본 값으로 실제 숫자를 반환해줄 장치가 필요하다.

DP 문제에서 기본 값을 찾는 일은 논리적으로 조금만 생각을 한다면 가장 쉬운 문제이다.

계단 문제에 대한 기본 값을 찾아보자. DP 를 사용하는 일 없이 내가 찾을 수 있는 답은 무엇인가를 생각해보면 아래의 종류 밖에 없다.

- 계단 1에 도달하기 위해 한 계단을 밟는다.
- 계단 2에 도달하기 위해 한 계단씩 밟거나, 두 계단을 한 번에 점프한다.

즉 기본 값을 도출하면 다음과 같다.

*dp(1) = 1, dp(2) = 2*

# 3. 예제 코드

## 3.1 Top-down

```java
class Solution {
    public int climbStairs(int n) {
        return helper(n);
    }
    
    public int helper(int i) {
        if(i <= 2) {
            return i;
        }
        return helper(i-1) + helper(i-2);
    }
}
```

가장 단순한 형태의 답안이다. 중요한 것은 재귀를 사용하면서 어떤 것도 **기록**하지 않았다. 이 코드의 시간 복잡도는 O(2<sup>n</sup>) 이 된다.
왜냐하면, DP에 대한 모든 호출이 2번의 추가 호출을 생성하기 때문이다.

만약 250 계단까지 올라갈 수 있는 방법이 몇 가지인지 알고 싶다면 작업의 수는 우주의 원자 수와 거의 같다.

사실 메모이제이션이 없으면 실제로 DP라고 부를 수 없다. 단지 기본 재귀일 뿐이다. 반복 계산을 피하기 위해 메모이제이션을 적용해야 DP라고 부를 수 있다. 메모이제이션 하기 위한 방법으로는 배열에 저장하거나, 해시 맵을 이용한 방법이 있다.

메모이제이션을 적용한 코드는 다음과 같다.

```java
class Solution {
	private Map<Integer, Integer> memo = new HashMap<>();

	private int helper(int i) {
		if(i <= 2) {
			return i;
		}

        //helper(i-1) + helper(i-2) 를 리턴하는 대신에 값을 계산하고
        // 그 값을 이후 스택 프레임에 사용하기 위해 해시 맵에 저장한다.
		if(!memo.containsKey(i)) {
			memo.put(i, helper(i-1) + helper(i-2));
		}

		return memo.get(i);
	}

	public int climbStairs(int n) {
		return helper(n);
	}
}
```

메모이제이션을 사용하면 시간 복잡도가 _O(n)_ 으로 줄어든다.

> 여기에서 해시맵이 캐싱에 과도하다는 것을 알 수 있으며, 해시맵 대신 배열을 이용할 수 있다. 하지만 일부 DP 문제에는 해시맵이 필요하기 때문에 해시맵을 사용하는 것이 나쁜 것은 아니다. 또한 top-down DP의 일부 문제에서는 모든 단일 하위 문제를 해결할 필요가 없다. 이 경우 배열은 해시맵보다 더 많은 공간을 사용할 수 있다.


## 3.2 Bottom-up

방정식이 세워져있으면 Top-down 방식과 크게 다르지 않다.

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1) return 1;
        
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        
        for(int i = 3; i <=n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
}
```