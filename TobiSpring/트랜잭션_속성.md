# 6.6 트랜잭션 속성

## 6.6.1 트랜잭션 정의

커밋, 롤백 외에도 트랜잭션의 동작방식을 제어할 수 있는 몇 가지 조건이 있다.
DefaultTransactionDefinition은 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의한다.

### 트랜잭션 전파

> **정의.**<br>
> 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.

![img_12.png](img_12.png)

B와 같이 독자적인 트랜잭션 경계를 가진 코드에 이미 진행 중인 트랜잭션이 어떻게 영향을 미칠 수 있는가를 정의하는 것이
트랜잭션 전파 속성이다.

#### PROPAGATION_REQUIRED

진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다. 가장 많이 사용되는 트랜잭션 전파 속성이다.

DefaultTransactionDefinition의 트랜잭션 전파 속성이 PROPAGATION_REQUIRED이다.

#### PROPAGATION_REQUIRES_NEW

항상 새로운 트랜잭션을 시작한다. 앞에서 시작된 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작하게 한다.

#### PROPAGATION_NOT_SUPPORTED

트랜잭션 없이 동장하도록 만들 수 있다. 트랜잭션을 무시하는 속성을 두는 데는 이유가 있다.
특정 메서드만 트랜잭션을 적용하기 싫을 때 포인트컷을 이용하는 방법보다 특정 트랜잭션의 전파 속성만
이 속성으로 두는 것이 훨씬 쉽기 때문이다.

트랜잭션 매니저를 통해 트랜잭션을 시작하려고 할 때 getTransaction()이라는 메서드를 사용하는 이유는 바로 이 트랜잭션 전파 속성이 있기 때문이다.

### 격리 수준

모든 DB 트랜잭션은 **격리 수준**을 갖고 있어야 한다.
서버 환경에서는 여러 개의 트랜잭션이 동시에 실행될 수 있는데, 가능하다면 모든 트랜잭션이 순차적으로 진행돼서 다른 트랜잭션의 작업에
독립적인 것이 좋겠지만, 그러자면 성능이 크게 떨어질 수 밖에 없기 때문이다. 따라서 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 
진행시키면서도 문제가 발생시키지 않게 하는 제어가 필요하다.

### 제한 시간

트랜잭션을 수행하는 제한시간을 설정할 수 있다.
DefaultTransactionDefinition의 기본 설정은 제한시간이 없다.
제한시간은 트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미 있다.

### 읽기 전용

읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.

TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션의 동작방식을 제어할 수 있다.
트랜잭션 정의를 수정하려면, DefaultTransactionDefinition을 사용하는 대신 외부에서 정의된 TransactionDefinition 오브젝트를
DI 받아서 사용해야 한다. TransactionDefinition 타입의 빈을 정의해두면 프로퍼티를 통해 원하는 속성을 지정해줄 수 있다.

하지만 이 방법은 TransactionAdvice를 사용하는 모든 트랜잭션의 속성이 한꺼번에 바뀐다는 단점이 있다.

## 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

메서드별로 다른 트랜잭션 정의를 사용하려면 어드바이스의 기능을 확장해야 한다.
메서드 이름 패턴에 따라 다른 트랜잭션 정의가 적용되도록 만드는 것이다.

### TransactionInterceptor

스프링은 편리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있도록 만들어진 TransactionInterceptor 를 지원한다.

TransactionInterceptor은 트랜잭션 정의를 메서드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해준다.
TransactionIntercpetor은 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다.

Properties 타입인 두 번째 프로퍼티 이름은 TransactionAttributes로, 트랜잭션 속성을 정의한 프로퍼티다.

스프링이 제공하는 TransactionInterceptor에는 기본적으로 두 가지 종류의 예외 처리 방식이 있다.

- 런타임 예외가 발생하면 트랜잭션은 롤백된다.
- 반면에 체크 예외를 던지는 경우에는 이것을 예외상황으로 해석하지 않고 트랜잭션을 커밋한다.

그런데 TransactionInterceptor의 이러한 예외처리 기본 원칙을 따르지 않는 경우가 있을 수 있다.
그래서 TransactionInterceptor은 rollbackOn()이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다.

TransactionInterceptor은 TransactionAttribute를 Properties라는 일종의 맵 타입 오브젝트로 전달받는다.
맵 타입인 이유는 메서드 패턴에 따라 각자 다른 트랜잭션 속성을 부여할 수 있게 하기 위해서다.

### 메서드 이름 패턴을 이용한 트랜잭션 속성 지정

Properties 타입의 TransactionAttributes 프로퍼티는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.

> **양식.**<br/>
> PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNN, -Exception1, +Exception2

양식에서 트랜잭션 전파 항목만 필수이고 나머지는 모두 생략 가능하다.
또 모든 항목이 구분 가능하기 때문에 순서는 상관없다.

모든 런타임 예외는 롤백돼야 하지만 +XXXRuntimeException이라고 해주면 런타임 예외라도 커밋하게 만들 수 있다.
반대로 체크 예외는 -XXXException을 붙여서 넣어주면 트랜잭션 롤백 대상이 된다.

### tx 네임스페이스를 이용한 설정 방법

트랜잭션 어드바이스도 포인트컷만큼 자주 사용되기 때문에 tx 스키마의 전용 태그를 이용해 정의할 수 있도록 스프링이 지원해준다.

```xml
<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="get*" propagation="REQUIRED" read-only="true" timeout="30"/>
        <tx:method name="upgrade*" propagation="REQUIRES_NEW" isolation="SERIALIZABLE"/>
        <tx:method name="*" propagation="REQUIRED"/>
    </tx:attributes>
</tx:advice>
```

빈 태그로 등록하는 경우에 비해 장점이 많으므로 tx 스키마의 태그를 사용해 어드바이스를 등록하도록 권장한다.

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

포인트컷 표현식과 트랜잭션 속성을 정의할 때 따르면 좋은 몇 가지 전략을 생각해보자

### 1. 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.

- 사용자 등록 메서드에도 트랜잭션이 필요하다.
사용자 정보를 DB에 추가하는 것 외에도 DB의 정보를 다루는 작업이 추가될 가능성이 높기 때문이다.
- 쓰기 작업이 없는 단순한 조회 작업만 하는 메서드에도 모두 트랜잭션을 적용하는 것이 좋다.
조회의 경우에는 읽기 전용으로 트랜잭션 속성을 설정해두면 그만큼의 성능 향상을 가져올 수 있다.
- 위 두 가지 이유들로 인해 트랜잭션용 포인트컷 표현식에는 메서드나 파라미터, 예외에 대한 패턴을 정의하지 않는게 바람직하다.
- 가능하면 클래스보다는 인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋다.
- 클래스나 인터페이스에 일정한 규칙을 만들기가 어려운 경우 bean() 표현식을 고려한다.

### 2. 공통된 메서드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.

가장 간단한 트랜잭션 속성 부여 방법은 모든 메서드에 대해 디폴트 속성을 지정하는 것이다.
일단 트랜잭션 속성의 종류와 메시지 패턴이 결정되지 않았으면 단순한 디폴트 속성부터 출발한 후, 개발이 진행됨에 따라 단계적으로
속성을 추가하면 된다.

```xml
<tx:advice id="transactionAdvice">
    <tx:attributes>
        <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
```

### 3. 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다.

이건 전략이라기보다는 주의사항이다.

![img_13.png](img_13.png)

[1]과 [3]처럼 클라이언트로부터 메서드가 호출되면 트랜잭션 프록시를 통해 타깃 메서드로 호출이 전달되므로
트랜잭션 경계설정 부가기능이 부여된다.

하지만 [2]번과 같은 경우, 즉 타깃 오브젝트 내로 들어와서 타깃 오브젝트의 다른 메서드를 호출하는 경우에는
프록시를 거치지 않고 직접 타깃의 메서드가 호출된다. 따라서 [1] 클라이언트를 통해 호출된 delete() 메서드는 트랜잭션 속성이 적용되지만
[2]를 통해 update() 메서드가 호출될 때는 트랜잭션 속성이 전혀 반영되지 않는다.

타깃 안에서의 호출에는 프록시가 적용되지 않는 문제를 해결할 수 있는 방법은 두 가지가 있다.

- 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메서드 호출도 프록시를 이용하도록 강제한다.
- AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용하는 것이다.

첫번째는 추천되지 않는 방법이다. 순수한 비즈니스 로직만을 남겨두려고 하는데, 거기에 스프링 API와 프록시 호출 코드가 등장하는 것은
바람직하지 않다.

